# DataStructure
 #### 자료구조

## 01.LinkedList : 연결 리스트

### 특징
1) 노드와 포인터로 이루어진 선형 자료구조
2) 노드는 데이터와 다음 노드를 가리키는 포인터로 구성된다
3) 크기가 가변적이므로 동적 메모리 할당과 함께 사용되기도 한다

### 장점
1) 삽입, 삭제가 용이하며 데이터의 크기가 가변적일 경우 유용하다
2) 데이터를 읽는 것보다 데이터를 추가, 삭제하는데 빠르다

### 단점
1) 데이터를 찾는데 걸리는 시간이 선형적으로 증가하기 때문에 탐색 속도가 느리다
2) 중간에 있는 노드를 삭제하면 메모리 낭비가 발생할 수도 있다

### 사용 예시
- 게임 맵
- 오브젝트의 리스트
- 인벤토리 등


## 02.Stack : 스택

### 특징
1) 후입선출(LIFO) 구조를 가지는 자료 구조
1) 삽입은 push, 삭제는 pop 연산을 사용

### 장점
1) 구현이 간단하다
2) 함수 호출의 역추적, 수식 게산, 문자열 역순 등에서 유용하다

### 단점
1) 중간의 원소에 접근하기 힘들다

### 사용 예시
- 캐릭터의 위치 저장
- 메뉴 구조
- 이전 페이지로 돌아가기 등


## 03.Queue : 큐

### 특징 
1) 선입선출(FIFO) 구조를 가지는 자료구조
2) 삽입은 EnQueue, 삭제는 DeQueue 연산을 사용

### 장점
1) 구현이 간단하다
2) 작업 처리 대기열, 메시지 전달 등에서 유용하다

### 단점
1) 큐의 크기가 고정되어 있을 때, 큐가 가득 차면 더 이상 데이터를 추가할 수 없다.

### 사용 예시
- 플레이어의 입력 처리(버퍼)
- 게임에서의 AI 동작 처리나 이벤트 처리 등


## 04.Tree : 트리

### 특징
1) 루트 노드를 제외한 모든 노드는 부모 노드가 있다
2) 하나의 루트 노드를 가진다
3) 노드는 0개 이상의 자식 노드를 가진다
4) 순환 구조를 가지지 않는다

### 장점
- 계층적인 구조를 표현할 수 있으며, 검색과 삽입, 삭제가 용이하다

### 단점
- 불균형한 트리는 탐색 시간이 느려진다
- 모든 트리 구조는 한계점을 가지고 있다 ( 시간이 지나면 결국 연결리스트의 형태를 띄게 됨 )

### 사용 예시
- 스킬 트리, 아이템 조합 과정, AI 등

### 순회
- 전위순회 - 현재 노드 -> 왼쪽 자식 -> 오른쪽 자식
- 중위순회 - 왼쪽 자식 -> 현재 노드 -> 오른쪽 자식
- 후외순회 - 왼쪽 자식 -> 오른쪽 자식 -> 현재 노드


## 05.Heap : 힙
### 특징
1) 완전 이진 트리 형태
2) 부모 노드와 자식 노드 간의 대소관게가 정해진 완전 이진 트리 구조
3) 루트 노드는 항상 최소값 또는 최대값을 가짐
4) 최소 힙 또는 최대 힙이 있다.
    - 최소 힙 : 부모 노드의 값이 자식 노드의 값보다 작은 경우
    - 최대 힙 : 부모 노드의 값이 자식 노드의 값보다 큰 경우

### 장점
1) 최소값 또는 최대값을 상수 시간(O(1))에 찾을 수 있다
2) 정렬, 우선순위 큐 등에서 유용하게 사용된다
3) 이진 탐색 트리보다 간단하고 빠르게 구현할 수 있다

### 단점
1) 중복된 값의 처리가 어렵다
2) 삽입, 삭제 연산에 시간복잡도가 O(log n)이 소요된다

### 사용 예시
- 능력치, 아이템 등을 저장


## Complete Binary Tree : 완전 이진 트리
### 특징
1) 모든 노드가 꽉 찬 이진트리
2) 마지막 레벨을 제외한 모든 레벨이 꽉 차있어야 한다
3) 마지막 레벨은 왼쪽부터 차례로 채워진다
4) 모든 노드는 왼쪽에서 오른쪽으로 채워져야 한다

### 장점
1) 배열로 구현할 때 간단하게 구현할 수 있다
    - i 번째 노드의 왼쪽 자식 노드는 2i 번째 노드
    - i 번째 노드의 오른쪽 자식 노드는 2i + 1번째 노드
    - i 번째 노드의 부모 노드는 i / 2 번째 노드
2) 탐색 시간이 O(log n)으로 매우 빠르다
3) 노드의 개수가 적어 공간 복잡도가 작다

### 단점
1) 삽입과 삭제 시 노드의 이동이 많아서 시간 복잡도가 높다

### 모두 꽉 차있는 트리 : 포화 이진 트리
### 마지막 레벨에서 하나라도 빠져 있는 트리 = 완전 이진 트리


## Graph : 그래프
### 특징
1) 정점(Vertex)과 간선(Edge)으로 구성된 자료 구조
2) 간선은 방향성과 가중치를 가질 수 있다
3) 방향 그래프, 무방향 그래프가 있다.
4) 그래프 내의 경로를 탐색할 수 있다

### 장점
1) 현실 세계를 모델링하기에 용이하다
2) 많은 문제를 그래프 모델로 변환하여 사용할 수 있다
3) 최단 경로, 최소 신장 트리 등 다양한 알고리즘이 존재한다

### 단점
- 메모리를 많이 차지하기 때문에 큰 그래프를 다루기 어려울 수 있다

### 사용 예시
- 경로 찾기


---
# Algorithm
#### 알고리즘

### 정렬 - 카드패를 섞어놨다고 생각하고 이해해보기

## Selection Sort : 선택 정렬
### 시간 복잡도 : O(n^2)
### 특징
- 현재 위치에서 가장 작은(혹은 가장 큰) 원소를 찾아서 맨 앞으로 이동시키는 알고리즘
### 장점
- 구현이 간단하며 공간 복잡도가 작다
### 단점
1) 시간 복잡도가 크기 때문에 대용량 데이터에 적용하기 어렵다
2) 불안정 정렬이기 때문에 같은 값의 경우 위치가 변경될 수 있다

## Insertion Sort : 삽입 정렬
### 시간 복잡도 : O(n^2)
### 특징
- 정렬되지 않은 부분의 가장 첫 번째 원소를 정렬된 부분에 삽입하는 방식으로 정렬을 수행하는 알고리즘
### 장점
1) 구현이 간단하며 작은 데이터에서는 선택 정렬과 거의 비슷한 성능을 보인다
2) 대부분이 이미 정렬된 데이터에 대해서는 빠른 속도로 정렬이 가능하다
### 단점
1) 최악의 경우 시간 복잡도가 매우 느리다
2) 불안정 정렬이기 때문에 같은 값의 경우 위치가 변경될 수 있다

## Bubble Sort : 버블 정렬
### 시간 복잡도 : O(n^2)
### 특징
- 인접한 두 원소를 비교하여 큰 값을 정해진 방향으로 이동시키며 정렬하는 알고리즘
### 장점
- 구현이 간단하다
### 단점
1) 시간 복잡도가 크기 때문에 대용량 데이터에 적용하기 어렵다
2) 불안정 정렬이기 때문에 같은 값의 경우 위치가 변경될 수 있다

## Quick Sort : 퀵 정렬
### 시간 복잡도
- 평균 : O(n log n)
- 최악 : O(n^2)
### 특징
1) 분할 정복 방법을 사용하는 알고리즘
2) pivot을 기준으로 좌우로 분할하여 정렬하는 방식으로 동작
### 장점
1) 대부분의 경우 빠른 속도로 정렬을 수행한다
2) 메모리 사용량이 적다
### 단점
1) 정렬하고자 하는 배열이 이미 정렬되어 있거나   
   모든 원소의 값이 같은 경우 시간 복잡도가 O(n^2)가 되어 성능이 급격히 저하된다
2) 불균형한 분할이 발생할 경우 성능이 떨어지는 경향이 있다

## Merge Sort : 병합 정렬
### 시간 복잡도
O(n log n)
### 특징
1) 분할 정복 방법을 사용하는 알고리즘
2) 리스트를 반씩 나눠가며 정렬 후 병합
### 장점
1) 안정 정렬에 속한다
2) 큰 데이터를 처리할 때 다른 알고리즘에 비해 상대적으로 빠른 성능
### 단점
- 정렬된 리스트를 추가로 저장해야 하기 때문에 메모리 공간이 더 필요 (공간 복잡도 ↑)